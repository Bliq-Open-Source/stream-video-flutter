// Code generated by protoc-gen-flutter-twirp. DO NOT EDIT. video/sfu/sfu_signal_rpc/signal

import 'dart:convert';

import 'package:http/http.dart' as http;
import 'package:protobuf/protobuf.dart';
import 'package:tart/tart.dart' as twirp;
import 'signal.pb.dart';
import 'package:stream_video/protobuf/video/sfu/sfu_models/models.pb.dart';



abstract class SignalServer {
  // Join sets up the peer connection that is used to subscribe to A/V and the data channel for signaling// in WebRTC terms, this contains the SDP offer for the user peer connection
  Future<JoinResponse> join(twirp.Context ctx, JoinRequest req);
  // SetPublisher sends the WebRTC offer for the peer connection used to publish A/V
  Future<SetPublisherResponse> setPublisher(twirp.Context ctx, SetPublisherRequest req);
  
  Future<SendAnswerResponse> sendAnswer(twirp.Context ctx, SendAnswerRequest req);
  
  Future<IceCandidateResponse> sendIceCandidate(twirp.Context ctx, IceCandidateRequest req);
  // UpdateSubscribers is used to notify the SFU about the list of video subscriptions// TODO: sync subscriptions based on this + update tracks using the dimension info sent by the user
  Future<UpdateSubscriptionsResponse> updateSubscriptions(twirp.Context ctx, UpdateSubscriptionsRequest req);
  
  Future<UpdateMuteStateResponse> updateMuteState(twirp.Context ctx, UpdateMuteStateRequest req);
  
  Future<UpdateVideoQualityResponse> requestVideoQuality(twirp.Context ctx, UpdateVideoQualityRequest req);
}


class SignalServerJSONClient implements SignalServer {
  String baseUrl;
  String prefix;
  late twirp.ClientHooks hooks;
  late twirp.Interceptor interceptor;

  SignalServerJSONClient(this.baseUrl, this.prefix, {twirp.ClientHooks? hooks, twirp.Interceptor? interceptor}) {
    if (!baseUrl.endsWith('/')) baseUrl += '/';
    if (!prefix.endsWith('/')) prefix += '/';
    if (prefix.startsWith('/')) prefix = prefix.substring(1);

    this.hooks = hooks ?? twirp.ClientHooks();
    this.interceptor = interceptor ?? twirp.chainInterceptor([]);
  }

  @override
  Future<JoinResponse> join(twirp.Context ctx, JoinRequest req) async {
    ctx = twirp.withPackageName(ctx, 'sfu');
    ctx = twirp.withServiceName(ctx, 'SignalServer');
    ctx = twirp.withMethodName(ctx, 'Join');
    return interceptor((ctx, req) {
      return callJoin(ctx, req);
    })(ctx, req);
  }

  Future<JoinResponse> callJoin(twirp.Context ctx, JoinRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.sfu.SignalServer/Join');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final JoinResponse res = JoinResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<SetPublisherResponse> setPublisher(twirp.Context ctx, SetPublisherRequest req) async {
    ctx = twirp.withPackageName(ctx, 'sfu');
    ctx = twirp.withServiceName(ctx, 'SignalServer');
    ctx = twirp.withMethodName(ctx, 'SetPublisher');
    return interceptor((ctx, req) {
      return callSetPublisher(ctx, req);
    })(ctx, req);
  }

  Future<SetPublisherResponse> callSetPublisher(twirp.Context ctx, SetPublisherRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.sfu.SignalServer/SetPublisher');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final SetPublisherResponse res = SetPublisherResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<SendAnswerResponse> sendAnswer(twirp.Context ctx, SendAnswerRequest req) async {
    ctx = twirp.withPackageName(ctx, 'sfu');
    ctx = twirp.withServiceName(ctx, 'SignalServer');
    ctx = twirp.withMethodName(ctx, 'SendAnswer');
    return interceptor((ctx, req) {
      return callSendAnswer(ctx, req);
    })(ctx, req);
  }

  Future<SendAnswerResponse> callSendAnswer(twirp.Context ctx, SendAnswerRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.sfu.SignalServer/SendAnswer');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final SendAnswerResponse res = SendAnswerResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<IceCandidateResponse> sendIceCandidate(twirp.Context ctx, IceCandidateRequest req) async {
    ctx = twirp.withPackageName(ctx, 'sfu');
    ctx = twirp.withServiceName(ctx, 'SignalServer');
    ctx = twirp.withMethodName(ctx, 'SendIceCandidate');
    return interceptor((ctx, req) {
      return callSendIceCandidate(ctx, req);
    })(ctx, req);
  }

  Future<IceCandidateResponse> callSendIceCandidate(twirp.Context ctx, IceCandidateRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.sfu.SignalServer/SendIceCandidate');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final IceCandidateResponse res = IceCandidateResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<UpdateSubscriptionsResponse> updateSubscriptions(twirp.Context ctx, UpdateSubscriptionsRequest req) async {
    ctx = twirp.withPackageName(ctx, 'sfu');
    ctx = twirp.withServiceName(ctx, 'SignalServer');
    ctx = twirp.withMethodName(ctx, 'UpdateSubscriptions');
    return interceptor((ctx, req) {
      return callUpdateSubscriptions(ctx, req);
    })(ctx, req);
  }

  Future<UpdateSubscriptionsResponse> callUpdateSubscriptions(twirp.Context ctx, UpdateSubscriptionsRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.sfu.SignalServer/UpdateSubscriptions');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final UpdateSubscriptionsResponse res = UpdateSubscriptionsResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<UpdateMuteStateResponse> updateMuteState(twirp.Context ctx, UpdateMuteStateRequest req) async {
    ctx = twirp.withPackageName(ctx, 'sfu');
    ctx = twirp.withServiceName(ctx, 'SignalServer');
    ctx = twirp.withMethodName(ctx, 'UpdateMuteState');
    return interceptor((ctx, req) {
      return callUpdateMuteState(ctx, req);
    })(ctx, req);
  }

  Future<UpdateMuteStateResponse> callUpdateMuteState(twirp.Context ctx, UpdateMuteStateRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.sfu.SignalServer/UpdateMuteState');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final UpdateMuteStateResponse res = UpdateMuteStateResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<UpdateVideoQualityResponse> requestVideoQuality(twirp.Context ctx, UpdateVideoQualityRequest req) async {
    ctx = twirp.withPackageName(ctx, 'sfu');
    ctx = twirp.withServiceName(ctx, 'SignalServer');
    ctx = twirp.withMethodName(ctx, 'RequestVideoQuality');
    return interceptor((ctx, req) {
      return callRequestVideoQuality(ctx, req);
    })(ctx, req);
  }

  Future<UpdateVideoQualityResponse> callRequestVideoQuality(twirp.Context ctx, UpdateVideoQualityRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.sfu.SignalServer/RequestVideoQuality');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final UpdateVideoQualityResponse res = UpdateVideoQualityResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }
}


class SignalServerProtobufClient implements SignalServer {
  String baseUrl;
  String prefix;
  late twirp.ClientHooks hooks;
  late twirp.Interceptor interceptor;

  SignalServerProtobufClient(this.baseUrl, this.prefix, {twirp.ClientHooks? hooks, twirp.Interceptor? interceptor}) {
    if (!baseUrl.endsWith('/')) baseUrl += '/';
    if (!prefix.endsWith('/')) prefix += '/';
    if (prefix.startsWith('/')) prefix = prefix.substring(1);

    this.hooks = hooks ?? twirp.ClientHooks();
    this.interceptor = interceptor ?? twirp.chainInterceptor([]);
  }

  @override
  Future<JoinResponse> join(twirp.Context ctx, JoinRequest req) async {
    ctx = twirp.withPackageName(ctx, 'sfu');
    ctx = twirp.withServiceName(ctx, 'SignalServer');
    ctx = twirp.withMethodName(ctx, 'Join');
    return interceptor((ctx, req) {
      return callJoin(ctx, req);
    })(ctx, req);
  }

  Future<JoinResponse> callJoin(twirp.Context ctx, JoinRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.sfu.SignalServer/Join');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final JoinResponse res = JoinResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<SetPublisherResponse> setPublisher(twirp.Context ctx, SetPublisherRequest req) async {
    ctx = twirp.withPackageName(ctx, 'sfu');
    ctx = twirp.withServiceName(ctx, 'SignalServer');
    ctx = twirp.withMethodName(ctx, 'SetPublisher');
    return interceptor((ctx, req) {
      return callSetPublisher(ctx, req);
    })(ctx, req);
  }

  Future<SetPublisherResponse> callSetPublisher(twirp.Context ctx, SetPublisherRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.sfu.SignalServer/SetPublisher');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final SetPublisherResponse res = SetPublisherResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<SendAnswerResponse> sendAnswer(twirp.Context ctx, SendAnswerRequest req) async {
    ctx = twirp.withPackageName(ctx, 'sfu');
    ctx = twirp.withServiceName(ctx, 'SignalServer');
    ctx = twirp.withMethodName(ctx, 'SendAnswer');
    return interceptor((ctx, req) {
      return callSendAnswer(ctx, req);
    })(ctx, req);
  }

  Future<SendAnswerResponse> callSendAnswer(twirp.Context ctx, SendAnswerRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.sfu.SignalServer/SendAnswer');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final SendAnswerResponse res = SendAnswerResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<IceCandidateResponse> sendIceCandidate(twirp.Context ctx, IceCandidateRequest req) async {
    ctx = twirp.withPackageName(ctx, 'sfu');
    ctx = twirp.withServiceName(ctx, 'SignalServer');
    ctx = twirp.withMethodName(ctx, 'SendIceCandidate');
    return interceptor((ctx, req) {
      return callSendIceCandidate(ctx, req);
    })(ctx, req);
  }

  Future<IceCandidateResponse> callSendIceCandidate(twirp.Context ctx, IceCandidateRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.sfu.SignalServer/SendIceCandidate');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final IceCandidateResponse res = IceCandidateResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<UpdateSubscriptionsResponse> updateSubscriptions(twirp.Context ctx, UpdateSubscriptionsRequest req) async {
    ctx = twirp.withPackageName(ctx, 'sfu');
    ctx = twirp.withServiceName(ctx, 'SignalServer');
    ctx = twirp.withMethodName(ctx, 'UpdateSubscriptions');
    return interceptor((ctx, req) {
      return callUpdateSubscriptions(ctx, req);
    })(ctx, req);
  }

  Future<UpdateSubscriptionsResponse> callUpdateSubscriptions(twirp.Context ctx, UpdateSubscriptionsRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.sfu.SignalServer/UpdateSubscriptions');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final UpdateSubscriptionsResponse res = UpdateSubscriptionsResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<UpdateMuteStateResponse> updateMuteState(twirp.Context ctx, UpdateMuteStateRequest req) async {
    ctx = twirp.withPackageName(ctx, 'sfu');
    ctx = twirp.withServiceName(ctx, 'SignalServer');
    ctx = twirp.withMethodName(ctx, 'UpdateMuteState');
    return interceptor((ctx, req) {
      return callUpdateMuteState(ctx, req);
    })(ctx, req);
  }

  Future<UpdateMuteStateResponse> callUpdateMuteState(twirp.Context ctx, UpdateMuteStateRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.sfu.SignalServer/UpdateMuteState');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final UpdateMuteStateResponse res = UpdateMuteStateResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<UpdateVideoQualityResponse> requestVideoQuality(twirp.Context ctx, UpdateVideoQualityRequest req) async {
    ctx = twirp.withPackageName(ctx, 'sfu');
    ctx = twirp.withServiceName(ctx, 'SignalServer');
    ctx = twirp.withMethodName(ctx, 'RequestVideoQuality');
    return interceptor((ctx, req) {
      return callRequestVideoQuality(ctx, req);
    })(ctx, req);
  }

  Future<UpdateVideoQualityResponse> callRequestVideoQuality(twirp.Context ctx, UpdateVideoQualityRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.sfu.SignalServer/RequestVideoQuality');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final UpdateVideoQualityResponse res = UpdateVideoQualityResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }
}

Future<List<int>> doProtobufRequest(twirp.Context ctx, Uri url,
    twirp.ClientHooks hooks, GeneratedMessage msgReq) async {
  // setup http client
  final httpClient = http.Client();

  try {
    // create http request
    final req = createRequest(url, ctx, 'application/protobuf');

    // add request data to body
    req.bodyBytes = msgReq.writeToBuffer();

    // call onRequestPrepared hook for user to modify request
    ctx = hooks.onRequestPrepared(ctx, req);

    // send data
    final res = await httpClient.send(req);

    // if success, parse and return response
    if (res.statusCode == 200) {
      List<int> data = <int>[];
      await res.stream.listen((value) {
        data.addAll(value);
      }).asFuture();
      hooks.onResponseReceived(ctx);
      return Future.value(data);
    }

    // we received a twirp related error
    throw twirp.TwirpError.fromJson(
        json.decode(await res.stream.transform(utf8.decoder).join()), ctx);
  } on twirp.TwirpError catch (twirpErr) {
    hooks.onError(ctx, twirpErr);
    rethrow;
  } catch (e) {
    // catch http connection error or from onRequestPrepared
    final twirpErr = twirp.TwirpError.fromConnectionError(e.toString(), ctx);
    hooks.onError(ctx, twirpErr);
    throw twirpErr;
  } finally {
    httpClient.close();
  }
}

Future<String> doJSONRequest(twirp.Context ctx, Uri url,
    twirp.ClientHooks hooks, GeneratedMessage msgReq) async {
  // setup http client
  final httpClient = http.Client();

  try {
    // create http request
    final req = createRequest(url, ctx, 'application/json');

    // add request data to body
    req.body = json.encode(msgReq.toProto3Json());

    // call onRequestPrepared hook for user to modify request
    ctx = hooks.onRequestPrepared(ctx, req);

    // send data
    final res = await httpClient.send(req);

    // if success, parse and return response
    if (res.statusCode == 200) {
      final data = await res.stream.transform(utf8.decoder).join().then((data) {
        hooks.onResponseReceived(ctx);
        return data;
      });
      return Future.value(data);
    }

    // we received a twirp related error
    throw twirp.TwirpError.fromJson(
        json.decode(await res.stream.transform(utf8.decoder).join()), ctx);
  } on twirp.TwirpError catch (twirpErr) {
    hooks.onError(ctx, twirpErr);
    rethrow;
  } catch (e) {
    // catch http connection error or from onRequestPrepared
    final twirpErr = twirp.TwirpError.fromConnectionError(e.toString(), ctx);
    hooks.onError(ctx, twirpErr);
    throw twirpErr;
  } finally {
    httpClient.close();
  }
}

http.Request createRequest(
    Uri url, twirp.Context ctx, String applicationHeader) {
  // setup request
  final req = http.Request("POST", url);

  // add headers from context
  final headersFromCtx = twirp.retrieveHttpRequestHeaders(ctx) ?? {};
  req.headers.addAll(headersFromCtx);

  // add required headers
  req.headers['Accept'] = applicationHeader;
  req.headers['Content-Type'] = applicationHeader;

  return req;
}
