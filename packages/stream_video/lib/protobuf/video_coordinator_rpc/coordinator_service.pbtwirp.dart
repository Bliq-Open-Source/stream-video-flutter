// Code generated by protoc-gen-tarp. DO NOT EDIT. video_coordinator_rpc/coordinator_service

import 'dart:convert';

import 'package:http/http.dart' as http;
import 'package:protobuf/protobuf.dart';
import 'package:tart/tart.dart' as twirp;
import 'coordinator_service.pb.dart';
import '../google/protobuf/struct.pb.dart';
import '../google/protobuf/wrappers.pb.dart';
import '../validate/validate.pb.dart';
import '../video_models/models.pb.dart';



abstract class CallCoordinatorService {
  // CreateCall creates a new call that is unique for the combination of type and id fields// If a call with the same type and id already exists then the call will be updated based on the request (if allowed and if needed)// The user calling this endpoint will be created if necessary ({id: id})// The users listed in the participants field will also be created if necessary ({id: id})
  Future<CreateCallResponse> createCall(twirp.Context ctx, CreateCallRequest req);
  // GetCall retrieves the state for one call, the user calling this endpoint is created if missing
  Future<GetCallResponse> getCall(twirp.Context ctx, GetCallRequest req);
  
  Future<UpdateCallResponse> updateCall(twirp.Context ctx, UpdateCallRequest req);
  
  Future<DeleteCallResponse> deleteCall(twirp.Context ctx, DeleteCallRequest req);
  // JoinCall returns the call state and the list of edges that the user should be check for latency// this endpoint is meant to be used to prepare the information needed to call the SelectEdgeServer endpoint
  Future<JoinCallResponse> joinCall(twirp.Context ctx, JoinCallRequest req);
  
  Future<SelectEdgeServerResponse> selectEdgeServer(twirp.Context ctx, SelectEdgeServerRequest req);
  
  Future<LeaveCallResponse> leaveCall(twirp.Context ctx, LeaveCallRequest req);
  
  Future<EndCallResponse> endCall(twirp.Context ctx, EndCallRequest req);
  // AddDevice registers the mobile device for push notifications// this endpoint will create the user if missing// if a device with the same id and push_provider_name exists, then the operation will be ignored
  Future<AddDeviceResponse> addDevice(twirp.Context ctx, AddDeviceRequest req);
  
  Future<RemoveDeviceResponse> removeDevice(twirp.Context ctx, RemoveDeviceRequest req);
  
  Future<ListDevicesResponse> listDevices(twirp.Context ctx, ListDevicesRequest req);
  // add reaction should perhaps just be handled by chat
  Future<SendEventResponse> sendEvent(twirp.Context ctx, SendEventRequest req);
  
  Future<SendCustomEventResponse> sendCustomEvent(twirp.Context ctx, SendCustomEventRequest req);
  // server side sync & advanced endpoints
  Future<CreateOrUpdateCallsResponse> createOrUpdateCalls(twirp.Context ctx, CreateOrUpdateCallsRequest req);
  
  Future<CreateOrUpdateUsersResponse> createOrUpdateUsers(twirp.Context ctx, CreateOrUpdateUsersRequest req);
  // recording a call or transcribing a call can be// A. Enabled by default for a call type// B. Enabled when creating the call per the default call type settings// C. Configured differently for that specific call// D. Enabled during the call
  Future<TranscribeCallResponse> transcribeCall(twirp.Context ctx, TranscribeCallRequest req);
  
  Future<StopTranscribeCallResponse> stopTranscribeCall(twirp.Context ctx, StopTranscribeCallRequest req);
  // starts broadcast to HLS and/or RTMP, replaces existing settings if broadcasting is already started
  Future<StartBroadcastResponse> startBroadcast(twirp.Context ctx, StartBroadcastRequest req);
  // stops broadcasting to HLS and/or RTMP
  Future<StopBroadcastResponse> stopBroadcast(twirp.Context ctx, StopBroadcastRequest req);
  
  Future<StartRecordingResponse> startRecording(twirp.Context ctx, StartRecordingRequest req);
  
  Future<StopRecordingResponse> stopRecording(twirp.Context ctx, StopRecordingRequest req);
  
  Future<GetRecordingsResponse> getRecordings(twirp.Context ctx, GetRecordingsRequest req);
  // User & GDPR endpoints, delete user// we need to review the API contract based on Chat
  Future<CreateUserResponse> createUser(twirp.Context ctx, CreateUserRequest req);
  
  Future<DeleteUserResponse> deleteUser(twirp.Context ctx, DeleteUserRequest req);
  
  Future<ExportUserResponse> exportUser(twirp.Context ctx, ExportUserRequest req);
  // endpoint for storing stats (perhaps we should move this to the SFU layer though)
  Future<StoreCallStatsResponse> storeCallStats(twirp.Context ctx, StoreCallStatsRequest req);
  
  Future<GetCallStatsResponse> getCallStats(twirp.Context ctx, GetCallStatsRequest req);
  // endpoint for reviewing/rating the quality of calls
  Future<ReviewCallResponse> reviewCall(twirp.Context ctx, ReviewCallRequest req);
  // endpoint for users to report issues with a call
  Future<ReportIssueResponse> reportIssue(twirp.Context ctx, ReportIssueRequest req);
}


class CallCoordinatorServiceJSONClient implements CallCoordinatorService {
  String baseUrl;
  String prefix;
  late twirp.ClientHooks hooks;
  late twirp.Interceptor interceptor;

  CallCoordinatorServiceJSONClient(this.baseUrl, this.prefix, {twirp.ClientHooks? hooks, twirp.Interceptor? interceptor}) {
    if (!baseUrl.endsWith('/')) baseUrl += '/';
    if (!prefix.endsWith('/')) prefix += '/';
    if (prefix.startsWith('/')) prefix = prefix.substring(1);

    this.hooks = hooks ?? twirp.ClientHooks();
    this.interceptor = interceptor ?? twirp.chainInterceptor([]);
  }

  @override
  Future<CreateCallResponse> createCall(twirp.Context ctx, CreateCallRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'CreateCall');
    return interceptor((ctx, req) {
      return callCreateCall(ctx, req);
    })(ctx, req);
  }

  Future<CreateCallResponse> callCreateCall(twirp.Context ctx, CreateCallRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/CreateCall');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final CreateCallResponse res = CreateCallResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<GetCallResponse> getCall(twirp.Context ctx, GetCallRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'GetCall');
    return interceptor((ctx, req) {
      return callGetCall(ctx, req);
    })(ctx, req);
  }

  Future<GetCallResponse> callGetCall(twirp.Context ctx, GetCallRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/GetCall');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final GetCallResponse res = GetCallResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<UpdateCallResponse> updateCall(twirp.Context ctx, UpdateCallRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'UpdateCall');
    return interceptor((ctx, req) {
      return callUpdateCall(ctx, req);
    })(ctx, req);
  }

  Future<UpdateCallResponse> callUpdateCall(twirp.Context ctx, UpdateCallRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/UpdateCall');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final UpdateCallResponse res = UpdateCallResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<DeleteCallResponse> deleteCall(twirp.Context ctx, DeleteCallRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'DeleteCall');
    return interceptor((ctx, req) {
      return callDeleteCall(ctx, req);
    })(ctx, req);
  }

  Future<DeleteCallResponse> callDeleteCall(twirp.Context ctx, DeleteCallRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/DeleteCall');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final DeleteCallResponse res = DeleteCallResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<JoinCallResponse> joinCall(twirp.Context ctx, JoinCallRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'JoinCall');
    return interceptor((ctx, req) {
      return callJoinCall(ctx, req);
    })(ctx, req);
  }

  Future<JoinCallResponse> callJoinCall(twirp.Context ctx, JoinCallRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/JoinCall');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final JoinCallResponse res = JoinCallResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<SelectEdgeServerResponse> selectEdgeServer(twirp.Context ctx, SelectEdgeServerRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'SelectEdgeServer');
    return interceptor((ctx, req) {
      return callSelectEdgeServer(ctx, req);
    })(ctx, req);
  }

  Future<SelectEdgeServerResponse> callSelectEdgeServer(twirp.Context ctx, SelectEdgeServerRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/SelectEdgeServer');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final SelectEdgeServerResponse res = SelectEdgeServerResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<LeaveCallResponse> leaveCall(twirp.Context ctx, LeaveCallRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'LeaveCall');
    return interceptor((ctx, req) {
      return callLeaveCall(ctx, req);
    })(ctx, req);
  }

  Future<LeaveCallResponse> callLeaveCall(twirp.Context ctx, LeaveCallRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/LeaveCall');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final LeaveCallResponse res = LeaveCallResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<EndCallResponse> endCall(twirp.Context ctx, EndCallRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'EndCall');
    return interceptor((ctx, req) {
      return callEndCall(ctx, req);
    })(ctx, req);
  }

  Future<EndCallResponse> callEndCall(twirp.Context ctx, EndCallRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/EndCall');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final EndCallResponse res = EndCallResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<AddDeviceResponse> addDevice(twirp.Context ctx, AddDeviceRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'AddDevice');
    return interceptor((ctx, req) {
      return callAddDevice(ctx, req);
    })(ctx, req);
  }

  Future<AddDeviceResponse> callAddDevice(twirp.Context ctx, AddDeviceRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/AddDevice');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final AddDeviceResponse res = AddDeviceResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<RemoveDeviceResponse> removeDevice(twirp.Context ctx, RemoveDeviceRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'RemoveDevice');
    return interceptor((ctx, req) {
      return callRemoveDevice(ctx, req);
    })(ctx, req);
  }

  Future<RemoveDeviceResponse> callRemoveDevice(twirp.Context ctx, RemoveDeviceRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/RemoveDevice');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final RemoveDeviceResponse res = RemoveDeviceResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<ListDevicesResponse> listDevices(twirp.Context ctx, ListDevicesRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'ListDevices');
    return interceptor((ctx, req) {
      return callListDevices(ctx, req);
    })(ctx, req);
  }

  Future<ListDevicesResponse> callListDevices(twirp.Context ctx, ListDevicesRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/ListDevices');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final ListDevicesResponse res = ListDevicesResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<SendEventResponse> sendEvent(twirp.Context ctx, SendEventRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'SendEvent');
    return interceptor((ctx, req) {
      return callSendEvent(ctx, req);
    })(ctx, req);
  }

  Future<SendEventResponse> callSendEvent(twirp.Context ctx, SendEventRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/SendEvent');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final SendEventResponse res = SendEventResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<SendCustomEventResponse> sendCustomEvent(twirp.Context ctx, SendCustomEventRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'SendCustomEvent');
    return interceptor((ctx, req) {
      return callSendCustomEvent(ctx, req);
    })(ctx, req);
  }

  Future<SendCustomEventResponse> callSendCustomEvent(twirp.Context ctx, SendCustomEventRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/SendCustomEvent');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final SendCustomEventResponse res = SendCustomEventResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<CreateOrUpdateCallsResponse> createOrUpdateCalls(twirp.Context ctx, CreateOrUpdateCallsRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'CreateOrUpdateCalls');
    return interceptor((ctx, req) {
      return callCreateOrUpdateCalls(ctx, req);
    })(ctx, req);
  }

  Future<CreateOrUpdateCallsResponse> callCreateOrUpdateCalls(twirp.Context ctx, CreateOrUpdateCallsRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/CreateOrUpdateCalls');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final CreateOrUpdateCallsResponse res = CreateOrUpdateCallsResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<CreateOrUpdateUsersResponse> createOrUpdateUsers(twirp.Context ctx, CreateOrUpdateUsersRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'CreateOrUpdateUsers');
    return interceptor((ctx, req) {
      return callCreateOrUpdateUsers(ctx, req);
    })(ctx, req);
  }

  Future<CreateOrUpdateUsersResponse> callCreateOrUpdateUsers(twirp.Context ctx, CreateOrUpdateUsersRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/CreateOrUpdateUsers');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final CreateOrUpdateUsersResponse res = CreateOrUpdateUsersResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<TranscribeCallResponse> transcribeCall(twirp.Context ctx, TranscribeCallRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'TranscribeCall');
    return interceptor((ctx, req) {
      return callTranscribeCall(ctx, req);
    })(ctx, req);
  }

  Future<TranscribeCallResponse> callTranscribeCall(twirp.Context ctx, TranscribeCallRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/TranscribeCall');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final TranscribeCallResponse res = TranscribeCallResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<StopTranscribeCallResponse> stopTranscribeCall(twirp.Context ctx, StopTranscribeCallRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'StopTranscribeCall');
    return interceptor((ctx, req) {
      return callStopTranscribeCall(ctx, req);
    })(ctx, req);
  }

  Future<StopTranscribeCallResponse> callStopTranscribeCall(twirp.Context ctx, StopTranscribeCallRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/StopTranscribeCall');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final StopTranscribeCallResponse res = StopTranscribeCallResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<StartBroadcastResponse> startBroadcast(twirp.Context ctx, StartBroadcastRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'StartBroadcast');
    return interceptor((ctx, req) {
      return callStartBroadcast(ctx, req);
    })(ctx, req);
  }

  Future<StartBroadcastResponse> callStartBroadcast(twirp.Context ctx, StartBroadcastRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/StartBroadcast');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final StartBroadcastResponse res = StartBroadcastResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<StopBroadcastResponse> stopBroadcast(twirp.Context ctx, StopBroadcastRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'StopBroadcast');
    return interceptor((ctx, req) {
      return callStopBroadcast(ctx, req);
    })(ctx, req);
  }

  Future<StopBroadcastResponse> callStopBroadcast(twirp.Context ctx, StopBroadcastRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/StopBroadcast');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final StopBroadcastResponse res = StopBroadcastResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<StartRecordingResponse> startRecording(twirp.Context ctx, StartRecordingRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'StartRecording');
    return interceptor((ctx, req) {
      return callStartRecording(ctx, req);
    })(ctx, req);
  }

  Future<StartRecordingResponse> callStartRecording(twirp.Context ctx, StartRecordingRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/StartRecording');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final StartRecordingResponse res = StartRecordingResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<StopRecordingResponse> stopRecording(twirp.Context ctx, StopRecordingRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'StopRecording');
    return interceptor((ctx, req) {
      return callStopRecording(ctx, req);
    })(ctx, req);
  }

  Future<StopRecordingResponse> callStopRecording(twirp.Context ctx, StopRecordingRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/StopRecording');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final StopRecordingResponse res = StopRecordingResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<GetRecordingsResponse> getRecordings(twirp.Context ctx, GetRecordingsRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'GetRecordings');
    return interceptor((ctx, req) {
      return callGetRecordings(ctx, req);
    })(ctx, req);
  }

  Future<GetRecordingsResponse> callGetRecordings(twirp.Context ctx, GetRecordingsRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/GetRecordings');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final GetRecordingsResponse res = GetRecordingsResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<CreateUserResponse> createUser(twirp.Context ctx, CreateUserRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'CreateUser');
    return interceptor((ctx, req) {
      return callCreateUser(ctx, req);
    })(ctx, req);
  }

  Future<CreateUserResponse> callCreateUser(twirp.Context ctx, CreateUserRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/CreateUser');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final CreateUserResponse res = CreateUserResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<DeleteUserResponse> deleteUser(twirp.Context ctx, DeleteUserRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'DeleteUser');
    return interceptor((ctx, req) {
      return callDeleteUser(ctx, req);
    })(ctx, req);
  }

  Future<DeleteUserResponse> callDeleteUser(twirp.Context ctx, DeleteUserRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/DeleteUser');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final DeleteUserResponse res = DeleteUserResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<ExportUserResponse> exportUser(twirp.Context ctx, ExportUserRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'ExportUser');
    return interceptor((ctx, req) {
      return callExportUser(ctx, req);
    })(ctx, req);
  }

  Future<ExportUserResponse> callExportUser(twirp.Context ctx, ExportUserRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/ExportUser');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final ExportUserResponse res = ExportUserResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<StoreCallStatsResponse> storeCallStats(twirp.Context ctx, StoreCallStatsRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'StoreCallStats');
    return interceptor((ctx, req) {
      return callStoreCallStats(ctx, req);
    })(ctx, req);
  }

  Future<StoreCallStatsResponse> callStoreCallStats(twirp.Context ctx, StoreCallStatsRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/StoreCallStats');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final StoreCallStatsResponse res = StoreCallStatsResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<GetCallStatsResponse> getCallStats(twirp.Context ctx, GetCallStatsRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'GetCallStats');
    return interceptor((ctx, req) {
      return callGetCallStats(ctx, req);
    })(ctx, req);
  }

  Future<GetCallStatsResponse> callGetCallStats(twirp.Context ctx, GetCallStatsRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/GetCallStats');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final GetCallStatsResponse res = GetCallStatsResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<ReviewCallResponse> reviewCall(twirp.Context ctx, ReviewCallRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'ReviewCall');
    return interceptor((ctx, req) {
      return callReviewCall(ctx, req);
    })(ctx, req);
  }

  Future<ReviewCallResponse> callReviewCall(twirp.Context ctx, ReviewCallRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/ReviewCall');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final ReviewCallResponse res = ReviewCallResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<ReportIssueResponse> reportIssue(twirp.Context ctx, ReportIssueRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'ReportIssue');
    return interceptor((ctx, req) {
      return callReportIssue(ctx, req);
    })(ctx, req);
  }

  Future<ReportIssueResponse> callReportIssue(twirp.Context ctx, ReportIssueRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/ReportIssue');
      final data = await doJSONRequest(ctx, url, hooks, req);
      final ReportIssueResponse res = ReportIssueResponse.create();
      res.mergeFromProto3Json(json.decode(data));
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }
}


class CallCoordinatorServiceProtobufClient implements CallCoordinatorService {
  String baseUrl;
  String prefix;
  late twirp.ClientHooks hooks;
  late twirp.Interceptor interceptor;

  CallCoordinatorServiceProtobufClient(this.baseUrl, this.prefix, {twirp.ClientHooks? hooks, twirp.Interceptor? interceptor}) {
    if (!baseUrl.endsWith('/')) baseUrl += '/';
    if (!prefix.endsWith('/')) prefix += '/';
    if (prefix.startsWith('/')) prefix = prefix.substring(1);

    this.hooks = hooks ?? twirp.ClientHooks();
    this.interceptor = interceptor ?? twirp.chainInterceptor([]);
  }

  @override
  Future<CreateCallResponse> createCall(twirp.Context ctx, CreateCallRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'CreateCall');
    return interceptor((ctx, req) {
      return callCreateCall(ctx, req);
    })(ctx, req);
  }

  Future<CreateCallResponse> callCreateCall(twirp.Context ctx, CreateCallRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/CreateCall');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final CreateCallResponse res = CreateCallResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<GetCallResponse> getCall(twirp.Context ctx, GetCallRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'GetCall');
    return interceptor((ctx, req) {
      return callGetCall(ctx, req);
    })(ctx, req);
  }

  Future<GetCallResponse> callGetCall(twirp.Context ctx, GetCallRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/GetCall');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final GetCallResponse res = GetCallResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<UpdateCallResponse> updateCall(twirp.Context ctx, UpdateCallRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'UpdateCall');
    return interceptor((ctx, req) {
      return callUpdateCall(ctx, req);
    })(ctx, req);
  }

  Future<UpdateCallResponse> callUpdateCall(twirp.Context ctx, UpdateCallRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/UpdateCall');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final UpdateCallResponse res = UpdateCallResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<DeleteCallResponse> deleteCall(twirp.Context ctx, DeleteCallRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'DeleteCall');
    return interceptor((ctx, req) {
      return callDeleteCall(ctx, req);
    })(ctx, req);
  }

  Future<DeleteCallResponse> callDeleteCall(twirp.Context ctx, DeleteCallRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/DeleteCall');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final DeleteCallResponse res = DeleteCallResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<JoinCallResponse> joinCall(twirp.Context ctx, JoinCallRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'JoinCall');
    return interceptor((ctx, req) {
      return callJoinCall(ctx, req);
    })(ctx, req);
  }

  Future<JoinCallResponse> callJoinCall(twirp.Context ctx, JoinCallRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/JoinCall');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final JoinCallResponse res = JoinCallResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<SelectEdgeServerResponse> selectEdgeServer(twirp.Context ctx, SelectEdgeServerRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'SelectEdgeServer');
    return interceptor((ctx, req) {
      return callSelectEdgeServer(ctx, req);
    })(ctx, req);
  }

  Future<SelectEdgeServerResponse> callSelectEdgeServer(twirp.Context ctx, SelectEdgeServerRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/SelectEdgeServer');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final SelectEdgeServerResponse res = SelectEdgeServerResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<LeaveCallResponse> leaveCall(twirp.Context ctx, LeaveCallRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'LeaveCall');
    return interceptor((ctx, req) {
      return callLeaveCall(ctx, req);
    })(ctx, req);
  }

  Future<LeaveCallResponse> callLeaveCall(twirp.Context ctx, LeaveCallRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/LeaveCall');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final LeaveCallResponse res = LeaveCallResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<EndCallResponse> endCall(twirp.Context ctx, EndCallRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'EndCall');
    return interceptor((ctx, req) {
      return callEndCall(ctx, req);
    })(ctx, req);
  }

  Future<EndCallResponse> callEndCall(twirp.Context ctx, EndCallRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/EndCall');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final EndCallResponse res = EndCallResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<AddDeviceResponse> addDevice(twirp.Context ctx, AddDeviceRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'AddDevice');
    return interceptor((ctx, req) {
      return callAddDevice(ctx, req);
    })(ctx, req);
  }

  Future<AddDeviceResponse> callAddDevice(twirp.Context ctx, AddDeviceRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/AddDevice');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final AddDeviceResponse res = AddDeviceResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<RemoveDeviceResponse> removeDevice(twirp.Context ctx, RemoveDeviceRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'RemoveDevice');
    return interceptor((ctx, req) {
      return callRemoveDevice(ctx, req);
    })(ctx, req);
  }

  Future<RemoveDeviceResponse> callRemoveDevice(twirp.Context ctx, RemoveDeviceRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/RemoveDevice');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final RemoveDeviceResponse res = RemoveDeviceResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<ListDevicesResponse> listDevices(twirp.Context ctx, ListDevicesRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'ListDevices');
    return interceptor((ctx, req) {
      return callListDevices(ctx, req);
    })(ctx, req);
  }

  Future<ListDevicesResponse> callListDevices(twirp.Context ctx, ListDevicesRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/ListDevices');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final ListDevicesResponse res = ListDevicesResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<SendEventResponse> sendEvent(twirp.Context ctx, SendEventRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'SendEvent');
    return interceptor((ctx, req) {
      return callSendEvent(ctx, req);
    })(ctx, req);
  }

  Future<SendEventResponse> callSendEvent(twirp.Context ctx, SendEventRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/SendEvent');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final SendEventResponse res = SendEventResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<SendCustomEventResponse> sendCustomEvent(twirp.Context ctx, SendCustomEventRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'SendCustomEvent');
    return interceptor((ctx, req) {
      return callSendCustomEvent(ctx, req);
    })(ctx, req);
  }

  Future<SendCustomEventResponse> callSendCustomEvent(twirp.Context ctx, SendCustomEventRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/SendCustomEvent');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final SendCustomEventResponse res = SendCustomEventResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<CreateOrUpdateCallsResponse> createOrUpdateCalls(twirp.Context ctx, CreateOrUpdateCallsRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'CreateOrUpdateCalls');
    return interceptor((ctx, req) {
      return callCreateOrUpdateCalls(ctx, req);
    })(ctx, req);
  }

  Future<CreateOrUpdateCallsResponse> callCreateOrUpdateCalls(twirp.Context ctx, CreateOrUpdateCallsRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/CreateOrUpdateCalls');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final CreateOrUpdateCallsResponse res = CreateOrUpdateCallsResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<CreateOrUpdateUsersResponse> createOrUpdateUsers(twirp.Context ctx, CreateOrUpdateUsersRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'CreateOrUpdateUsers');
    return interceptor((ctx, req) {
      return callCreateOrUpdateUsers(ctx, req);
    })(ctx, req);
  }

  Future<CreateOrUpdateUsersResponse> callCreateOrUpdateUsers(twirp.Context ctx, CreateOrUpdateUsersRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/CreateOrUpdateUsers');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final CreateOrUpdateUsersResponse res = CreateOrUpdateUsersResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<TranscribeCallResponse> transcribeCall(twirp.Context ctx, TranscribeCallRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'TranscribeCall');
    return interceptor((ctx, req) {
      return callTranscribeCall(ctx, req);
    })(ctx, req);
  }

  Future<TranscribeCallResponse> callTranscribeCall(twirp.Context ctx, TranscribeCallRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/TranscribeCall');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final TranscribeCallResponse res = TranscribeCallResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<StopTranscribeCallResponse> stopTranscribeCall(twirp.Context ctx, StopTranscribeCallRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'StopTranscribeCall');
    return interceptor((ctx, req) {
      return callStopTranscribeCall(ctx, req);
    })(ctx, req);
  }

  Future<StopTranscribeCallResponse> callStopTranscribeCall(twirp.Context ctx, StopTranscribeCallRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/StopTranscribeCall');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final StopTranscribeCallResponse res = StopTranscribeCallResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<StartBroadcastResponse> startBroadcast(twirp.Context ctx, StartBroadcastRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'StartBroadcast');
    return interceptor((ctx, req) {
      return callStartBroadcast(ctx, req);
    })(ctx, req);
  }

  Future<StartBroadcastResponse> callStartBroadcast(twirp.Context ctx, StartBroadcastRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/StartBroadcast');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final StartBroadcastResponse res = StartBroadcastResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<StopBroadcastResponse> stopBroadcast(twirp.Context ctx, StopBroadcastRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'StopBroadcast');
    return interceptor((ctx, req) {
      return callStopBroadcast(ctx, req);
    })(ctx, req);
  }

  Future<StopBroadcastResponse> callStopBroadcast(twirp.Context ctx, StopBroadcastRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/StopBroadcast');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final StopBroadcastResponse res = StopBroadcastResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<StartRecordingResponse> startRecording(twirp.Context ctx, StartRecordingRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'StartRecording');
    return interceptor((ctx, req) {
      return callStartRecording(ctx, req);
    })(ctx, req);
  }

  Future<StartRecordingResponse> callStartRecording(twirp.Context ctx, StartRecordingRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/StartRecording');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final StartRecordingResponse res = StartRecordingResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<StopRecordingResponse> stopRecording(twirp.Context ctx, StopRecordingRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'StopRecording');
    return interceptor((ctx, req) {
      return callStopRecording(ctx, req);
    })(ctx, req);
  }

  Future<StopRecordingResponse> callStopRecording(twirp.Context ctx, StopRecordingRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/StopRecording');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final StopRecordingResponse res = StopRecordingResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<GetRecordingsResponse> getRecordings(twirp.Context ctx, GetRecordingsRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'GetRecordings');
    return interceptor((ctx, req) {
      return callGetRecordings(ctx, req);
    })(ctx, req);
  }

  Future<GetRecordingsResponse> callGetRecordings(twirp.Context ctx, GetRecordingsRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/GetRecordings');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final GetRecordingsResponse res = GetRecordingsResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<CreateUserResponse> createUser(twirp.Context ctx, CreateUserRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'CreateUser');
    return interceptor((ctx, req) {
      return callCreateUser(ctx, req);
    })(ctx, req);
  }

  Future<CreateUserResponse> callCreateUser(twirp.Context ctx, CreateUserRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/CreateUser');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final CreateUserResponse res = CreateUserResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<DeleteUserResponse> deleteUser(twirp.Context ctx, DeleteUserRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'DeleteUser');
    return interceptor((ctx, req) {
      return callDeleteUser(ctx, req);
    })(ctx, req);
  }

  Future<DeleteUserResponse> callDeleteUser(twirp.Context ctx, DeleteUserRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/DeleteUser');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final DeleteUserResponse res = DeleteUserResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<ExportUserResponse> exportUser(twirp.Context ctx, ExportUserRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'ExportUser');
    return interceptor((ctx, req) {
      return callExportUser(ctx, req);
    })(ctx, req);
  }

  Future<ExportUserResponse> callExportUser(twirp.Context ctx, ExportUserRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/ExportUser');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final ExportUserResponse res = ExportUserResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<StoreCallStatsResponse> storeCallStats(twirp.Context ctx, StoreCallStatsRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'StoreCallStats');
    return interceptor((ctx, req) {
      return callStoreCallStats(ctx, req);
    })(ctx, req);
  }

  Future<StoreCallStatsResponse> callStoreCallStats(twirp.Context ctx, StoreCallStatsRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/StoreCallStats');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final StoreCallStatsResponse res = StoreCallStatsResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<GetCallStatsResponse> getCallStats(twirp.Context ctx, GetCallStatsRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'GetCallStats');
    return interceptor((ctx, req) {
      return callGetCallStats(ctx, req);
    })(ctx, req);
  }

  Future<GetCallStatsResponse> callGetCallStats(twirp.Context ctx, GetCallStatsRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/GetCallStats');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final GetCallStatsResponse res = GetCallStatsResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<ReviewCallResponse> reviewCall(twirp.Context ctx, ReviewCallRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'ReviewCall');
    return interceptor((ctx, req) {
      return callReviewCall(ctx, req);
    })(ctx, req);
  }

  Future<ReviewCallResponse> callReviewCall(twirp.Context ctx, ReviewCallRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/ReviewCall');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final ReviewCallResponse res = ReviewCallResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }

  @override
  Future<ReportIssueResponse> reportIssue(twirp.Context ctx, ReportIssueRequest req) async {
    ctx = twirp.withPackageName(ctx, 'video');
    ctx = twirp.withServiceName(ctx, 'CallCoordinatorService');
    ctx = twirp.withMethodName(ctx, 'ReportIssue');
    return interceptor((ctx, req) {
      return callReportIssue(ctx, req);
    })(ctx, req);
  }

  Future<ReportIssueResponse> callReportIssue(twirp.Context ctx, ReportIssueRequest req) async {
    try {
      Uri url = Uri.parse(baseUrl + prefix + 'stream.video.CallCoordinatorService/ReportIssue');
      final data = await doProtobufRequest(ctx, url, hooks, req);
      final ReportIssueResponse res = ReportIssueResponse.create();
      res.mergeFromBuffer(data);
      return Future.value(res);
    } catch (e) {
      rethrow;
    }
  }
}

Future<List<int>> doProtobufRequest(twirp.Context ctx, Uri url,
    twirp.ClientHooks hooks, GeneratedMessage msgReq) async {
  // setup http client
  final httpClient = http.Client();

  try {
    // create http request
    final req = createRequest(url, ctx, 'application/protobuf');

    // add request data to body
    req.bodyBytes = msgReq.writeToBuffer();

    // call onRequestPrepared hook for user to modify request
    ctx = hooks.onRequestPrepared(ctx, req);

    // send data
    final res = await httpClient.send(req);

    // if success, parse and return response
    if (res.statusCode == 200) {
      List<int> data = <int>[];
      await res.stream.listen((value) {
        data.addAll(value);
      }).asFuture();
      hooks.onResponseReceived(ctx);
      return Future.value(data);
    }

    // we received a twirp related error
    throw twirp.TwirpError.fromJson(
        json.decode(await res.stream.transform(utf8.decoder).join()), ctx);
  } on twirp.TwirpError catch (twirpErr) {
    hooks.onError(ctx, twirpErr);
    rethrow;
  } catch (e) {
    // catch http connection error or from onRequestPrepared
    final twirpErr = twirp.TwirpError.fromConnectionError(e.toString(), ctx);
    hooks.onError(ctx, twirpErr);
    throw twirpErr;
  } finally {
    httpClient.close();
  }
}

Future<String> doJSONRequest(twirp.Context ctx, Uri url,
    twirp.ClientHooks hooks, GeneratedMessage msgReq) async {
  // setup http client
  final httpClient = http.Client();

  try {
    // create http request
    final req = createRequest(url, ctx, 'application/json');

    // add request data to body
    req.body = json.encode(msgReq.toProto3Json());

    // call onRequestPrepared hook for user to modify request
    ctx = hooks.onRequestPrepared(ctx, req);

    // send data
    final res = await httpClient.send(req);

    // if success, parse and return response
    if (res.statusCode == 200) {
      final data = await res.stream.transform(utf8.decoder).join().then((data) {
        hooks.onResponseReceived(ctx);
        return data;
      });
      return Future.value(data);
    }

    // we received a twirp related error
    throw twirp.TwirpError.fromJson(
        json.decode(await res.stream.transform(utf8.decoder).join()), ctx);
  } on twirp.TwirpError catch (twirpErr) {
    hooks.onError(ctx, twirpErr);
    rethrow;
  } catch (e) {
    // catch http connection error or from onRequestPrepared
    final twirpErr = twirp.TwirpError.fromConnectionError(e.toString(), ctx);
    hooks.onError(ctx, twirpErr);
    throw twirpErr;
  } finally {
    httpClient.close();
  }
}

http.Request createRequest(
    Uri url, twirp.Context ctx, String applicationHeader) {
  // setup request
  final req = http.Request("POST", url);

  // add headers from context
  final headersFromCtx = twirp.retrieveHttpRequestHeaders(ctx) ?? {};
  req.headers.addAll(headersFromCtx);

  // add required headers
  req.headers['Accept'] = applicationHeader;
  req.headers['Content-Type'] = applicationHeader;

  return req;
}
